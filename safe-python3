#!/usr/bin/env perl

# A "safe" proxy for a python3 executable.
# Note: probably very unsafe. Take additional
# measures to secure your deployment.
# Run -h for help / usage.

# Constraints:
# Python output (yes, even errors) should exclusively happen on STDOUT
# STDERR is supposed to be the place for errors in *this* script

use strict;
use warnings;
use 5.26.0;

use File::Temp qw();
use Getopt::Long qw(GetOptions);
use JSON::PP qw(decode_json encode_json);

use Capture::Tiny qw(capture_merged);
use IPC::Run qw(run timeout);

my @REAL_PYTHON = qw(/usr/bin/python3 -B -E -I -s);
my $PYTHON_TIMEOUT = 5; # seconds

my $PY_START_LINE = qr{
    ^
    \s*?      # It's ok to have some whitespace
    (?=[^\#]) # Ignore comments (TODO: also handle docstrings?)
    .*?       # Don't care what comes here
}xm;

# Watch out for new functions:
# https://docs.python.org/3.7/library/functions.html
my $PYx_BANNED_FUNCTIONS = qr{
    (?<MATCH_BANNED>
    classmethod | compile | delattr | dir |
    eval | exec | getattr | globals | hasattr |
    help | id | input | isinstance | issubclass |
    locals | memoryview | open | setattr | vars |
    __.*?__
)}x;

my $PYx_BANNED_STATEMENTS = qr{
    (?<MATCH_BANNED>
    import
)}x;

sub print_usage {
  print <<"EOF";
Usage:
    $0 --script=<path> [ --prologue=<path> | --epilogue=<path> ]
    $0 [ -h | --help ]
EOF
}

sub make_json_response {
  return encode_json {
    ball => {x => '0', y => '0'},
    stdout => shift
  };
}

sub fake_name_error {

  my $identifier = shift;

  print STDOUT make_json_response(
    "NameError: name '$identifier' is not defined");
  exit -1;
}

sub slurp_utf8 {

  my $fn = shift;

  local $/ = undef;

  open(my $fh, '<:encoding(UTF-8)', $fn)
      or die "Could not open file $fn: $!";
  my $data = <$fh>;
  close($fh)
      or die "Could not close file $fn: $!";

  return $data;
}

sub py_ban_functions {

  my $py = shift;

  my $forbidden = qr{
      ( # Maybe this is a decorator?
        $PY_START_LINE
        @ # decorator
        $PYx_BANNED_FUNCTIONS
      |
        $PY_START_LINE
        $PYx_BANNED_FUNCTIONS
      )
  }xm;

  if ($py =~ $forbidden) {
    fake_name_error($+{MATCH_BANNED});
  }

  return $py;
}

sub py_ban_statements {

  my $py = shift;

  my $forbidden = qr{
      $PY_START_LINE

      \b # prevent matches like ｢my_import_func｣
        $PYx_BANNED_STATEMENTS
      \b
  }xm;

  if ($py =~ $forbidden) {
    fake_name_error($+{MATCH_BANNED});
  }

  return $py;

}

sub py_rewrite_script {

  my $py_unsafe = shift;

  local $_ = $py_unsafe;

  $_ = py_ban_functions  $_;
  $_ = py_ban_statements $_;

  return $_;
}

sub main {

  binmode(STDIN,  ':encoding(UTF-8)');
  binmode(STDOUT, ':encoding(UTF-8)');
  binmode(STDERR, ':encoding(UTF-8)');

  my ($arg_script, $arg_prologue, $arg_epilogue, $arg_help);

  GetOptions('script=s'   => \$arg_script,
             'prologue=s' => \$arg_prologue,
             'epilogue=s' => \$arg_epilogue,
             'h|help'     => \$arg_help)
      or print "\n" and print_usage and exit;

  if ($arg_help) {
    print_usage;
    exit;
  }

  unless (defined $arg_script) {
    die "Missing argument: --script\n";
  }

  my $py_unsafe = slurp_utf8($arg_script);

  my $py_safe = py_rewrite_script($py_unsafe);

  my $temp_safe = File::Temp->new;
  $temp_safe->unlink_on_destroy(1);
  binmode($temp_safe, ':encoding(UTF-8)');

  print $temp_safe slurp_utf8($arg_prologue) . "\n"
      if defined $arg_prologue;
  print $temp_safe $py_safe . "\n";
  print $temp_safe slurp_utf8($arg_epilogue) . "\n"
      if defined $arg_epilogue;

  close($temp_safe) or die "Could not close tempfile: $!";

  # Run real python interpreter
  my $status;
  my @cmd = (@REAL_PYTHON => $temp_safe->filename);

  my $output;
  eval {
    run \@cmd, '>&', \$output, timeout($PYTHON_TIMEOUT);
  };
  if (my $e = $@) {
    if ($e =~ /IPC::Run: timeout/) {
      print STDOUT make_json_response(
        "Python interpreter timed out, please try again");
    } else {
      # TODO: turn this into a log
      print STDERR $e;
    }
  } else {
    eval {
      decode_json($output)
    };
    if ($@) {
      # Strip Python's /File "foo", line 60/
      $output =~ s/^\s*File (.*?), line (.*)?\n//;
      print STDOUT make_json_response($output);
    } else {
      # This is probably a valid response,
      # just return it
      print STDOUT $output;
    }
  }
}

main;
